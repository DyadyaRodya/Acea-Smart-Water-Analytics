---
title: "Ekz"
author: "Yulian Volianskiy"
date: "06 01 2021"
output: html_document
---

1. Reading data and transform Date from char to Date format

```{r}

setwd("E:/prazia/univer/DataScience/Ekz/acea-water-prediction")
df <- read.csv("Water_Spring_Lupa.csv")
df$п.їDate = strptime(df$п.їDate, "%d/%m/%Y")
df$Date <- ymd(df$п.їDate)
ggplot(data=df, aes(x=Date, y=Flow_Rate_Lupa)) + geom_line()
head(df)

df_data <- read.csv("water_spring_lupa_csv_r2.csv")
head(df_data)
df_train <- read.csv("water_spring_lupa_csv_r.csv")
head(df_data)

library(Amelia)
missmap(df_train, main = "Missing values vs observed")
missmap(df_data, main = "Missing values vs observed")

train1 <- head(df_train, 3000)
test1 <- tail(df_train, 817)

```
Here we can see a plot, that shows us an empty parts in our data. So first of all we should to find Nans and predict them. I divided data in two types:
1. Data with Nans
2. Data without empty fields

After that I divided data without empty fields into train and test datas. It will be useful for linear regresion model. 



Next step - I should create a logistic regresion using train data.
```{r}

library(ggplot2)
library(hexbin)

ggplot(df_train, aes(x = flow_rate_lupa, y = rainfall_terni)) + geom_point(alpha = 0.1)
hexbinplot(rainfall_terni ~ flow_rate_lupa, data=df_train)

df_trainLM = lm(flow_rate_lupa ~ rainfall_terni, data = df_train) #Create the linear regression
summary(df_trainLM)

```
If we'll inspect coeficients, we'll see that this model isn't strong due to:
R-squared - it's apeared to be too small, near zero.
p_value - not too small.
That can say us, that we need probably more data to culculate stronger linear regresion model.


Using prediction function we try to predict values in empty fields
```{r}

newdata1 <- test1$flow_rate_lupa
df_data$flow_rate_lupa <-predict(df_trainLM,newdata=df_data,type="response")
df_new <- rbind(df_data,df_train)

df_new$п.їDate = strptime(df_new$п.їDate, "%d/%m/%Y")
df_new$Date <- ymd(df_new$п.їDate)

ggplot(data=df_new, aes(x=Date, y=df_new$flow_rate_lupa)) + geom_line()

```
In the plot we can see that it hasn't even distribution, so that kind of prediction data doesn't fit.



Another way to predict data - using interpolation function, so lets try it:
```{r}
library(imputeTS)
library(lubridate)
df$Flow_Rate_Lupa <- na.interpolation(df$Flow_Rate_Lupa, option = "spline")


df$Date <- ymd(df$п.їDate)

library(ggplot2)

ggplot(data=df, aes(x=Date, y=Flow_Rate_Lupa)) + geom_line()

#plot(x=df$п.їDate, y=df$Flow_Rate_Lupa)

```
In the plot we can see, that it probably fits our problem and have even distribution in empty places. 

Prepare data and sort by date. Check timeinterval.

```{r}

library(data.table)

df <- df[order(df$Date), ]
df['Time_Interval'] = df$Date - shift(df$Date, n=1, fill=NA, type="lag")

days <- df$Time_Interval


for(i in days)
{
  
  if(isTRUE(i > 1) || is.null(i))
  {
    print(i)
  }
    
}

```


```{r}

library(tseries)
library(urca)

result<-ur.df(df$Flow_Rate_Lupa,type = "none",lags=1)
summary(result)

```

```{r}
library(ggplot2)


significance_level = 0.05
adf_stat = result@teststat[1]
p_val = 2.2e-16

crit_val_1 = result@cval[1]
crit_val_5 = result@cval[2]
crit_val_10 = result@cval[3]


linecolor = 'indianred'

if ((p_val < significance_level) & ((adf_stat < crit_val_1)))
  linecolor = 'forestgreen' 
if ((p_val < significance_level) & (adf_stat < crit_val_5))
  linecolor = 'gold'
if ((p_val < significance_level) & (adf_stat < crit_val_10))
  linecolor = 'orange'

ggplot(data=df, aes(x=Date, y=Flow_Rate_Lupa)) + geom_line(color=linecolor)

```

```{r}

result2<-ur.df(df$Rainfall_Terni,type = "none",lags=1)
summary(result2)

```


```{r}

significance_level = 0.05
adf_stat = result@teststat[1]
p_val = 2.2e-16

crit_val_1 = result@cval[1]
crit_val_5 = result@cval[2]
crit_val_10 = result@cval[3]


linecolor = 'indianred'

if ((p_val < significance_level) & ((adf_stat < crit_val_1)))
  linecolor = 'forestgreen' 
if ((p_val < significance_level) & (adf_stat < crit_val_5))
  linecolor = 'gold'
if ((p_val < significance_level) & (adf_stat < crit_val_10))
  linecolor = 'orange'

ggplot(data=df, aes(x=Date, y=Rainfall_Terni)) + geom_line(color=linecolor)

```

```{r}

df['Flow_Rate_Lupa_log'] = log10(abs(df$Flow_Rate_Lupa))
df['Rainfall_Terni_log'] = log10(abs(df$Rainfall_Terni))

is.na(df['Rainfall_Terni_log'])<-sapply(df['Rainfall_Terni_log'], is.infinite)
df['Rainfall_Terni_log'][is.na(df['Rainfall_Terni_log'])]<-0

is.na(df['Flow_Rate_Lupa_log'])<-sapply(df['Flow_Rate_Lupa_log'], is.infinite)
df['Flow_Rate_Lupa_log'][is.na(df['Flow_Rate_Lupa_log'])]<-0

ggplot(data=df, aes(x=Date, y=Flow_Rate_Lupa_log)) + geom_line()
ggplot(data=df, aes(x=Date, y=Rainfall_Terni_log)) + geom_line()

Flow_Rate_Lupa_log_diff <- diff(df$Flow_Rate_Lupa_log)
Rainfall_Terni_log_diff <- diff(df$Rainfall_Terni_log)

Flow_Rate_Lupa_log_diff <- append(Flow_Rate_Lupa_log_diff, 0, 0)
df['Flow_Rate_Lupa_log_diff'] = Flow_Rate_Lupa_log_diff
Rainfall_Terni_log_diff <- append(Rainfall_Terni_log_diff, 0, 0)
df['Rainfall_Terni_log_diff'] = Rainfall_Terni_log_diff

ggplot(data=df, aes(x=Date, y=Flow_Rate_Lupa_log_diff)) + geom_line()
ggplot(data=df, aes(x=Date, y=Rainfall_Terni_log_diff)) + geom_line()

```


```{r}

result3<-ur.df(df$Flow_Rate_Lupa_log,type = "none",lags=1)
summary(result3)

```


```{r}

significance_level = 0.05
adf_stat = result@teststat[1]
p_val = 2.2e-16

crit_val_1 = result@cval[1]
crit_val_5 = result@cval[2]
crit_val_10 = result@cval[3]


linecolor = 'indianred'

if ((p_val < significance_level) & ((adf_stat < crit_val_1)))
  linecolor = 'forestgreen' 
if ((p_val < significance_level) & (adf_stat < crit_val_5))
  linecolor = 'gold'
if ((p_val < significance_level) & (adf_stat < crit_val_10))
  linecolor = 'orange'

ggplot(data=df, aes(x=Date, y=Flow_Rate_Lupa_log_diff)) + geom_line(color=linecolor)

```


```{r}

library(stats)

myts <- ts(df$Rainfall_Terni, start=c(2009, 1, 1), end=c(2020, 30, 6), frequency=52)

decomp = decompose(myts, type='additive')

plot(decomp$trend)
plot(decomp$seasonal)

```

```{r}

myts <- ts(df$Flow_Rate_Lupa, start=c(2009, 1, 1), end=c(2020, 30, 6), frequency=52)

decomp = decompose(myts, type='additive')

plot(decomp$trend)
plot(decomp$seasonal)

```


```{r}

acf(df$Flow_Rate_Lupa_log_diff)
pacf(df$Flow_Rate_Lupa_log_diff)

```

```{r}

library(TSstudio)
library(forecast)
split_USgas <- ts_split(ts.obj = myts, 130)

plot(split_USgas$train)
plot(split_USgas$test)


autoplot(split_USgas$train) +
  autolayer(meanf(split_USgas$train),
    series="Mean", PI=FALSE) +
  autolayer(naive(split_USgas$train),
    series="Naïve", PI=FALSE) +
  autolayer(snaive(split_USgas$train),
    series="Seasonal naïve", PI=FALSE) +
   autolayer(split_USgas$test,
    series="Test", PI=FALSE)+
  ggtitle("Forecasts for quarterly beer production") +
  xlab("Year") + ylab("Megalitres") +
  guides(colour=guide_legend(title="Forecast"))

```

```{r}
#auto.arima(split_USgas$train, trace=TRUE) 

library(forecast)
fit <- Arima(split_USgas$train, order = c(0,1,1), include.drift = TRUE)
summary(fit)

futurVal <- forecast(fit,h=130, level=c(99.5))
plot(futurVal)

```










